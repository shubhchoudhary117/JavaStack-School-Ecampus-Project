/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
/**
 * @module html-support/dataschema
 */
import { Plugin } from 'ckeditor5/src/core';
import { toArray } from 'ckeditor5/src/utils';
import defaultConfig from './schemadefinitions';
import { mergeWith } from 'lodash-es';
/**
 * Holds representation of the extended HTML document type definitions to be used by the
 * editor in HTML support.
 *
 * Data schema is represented by data schema definitions.
 *
 * To add new definition for block element,
 * use {@link module:html-support/dataschema~DataSchema#registerBlockElement} method:
 *
 * ```ts
 * dataSchema.registerBlockElement( {
 * 	view: 'section',
 * 	model: 'my-section',
 * 	modelSchema: {
 * 		inheritAllFrom: '$block'
 * 	}
 * } );
 * ```
 *
 * To add new definition for inline element,
 * use {@link module:html-support/dataschema~DataSchema#registerInlineElement} method:
 *
 * ```
 * dataSchema.registerInlineElement( {
 * 	view: 'span',
 * 	model: 'my-span',
 * 	attributeProperties: {
 * 		copyOnEnter: true
 * 	}
 * } );
 * ```
 */
export default class DataSchema extends Plugin {
    constructor(editor) {
        super(editor);
        this._definitions = new Map();
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
        return 'DataSchema';
    }
    /**
     * @inheritDoc
     */
    init() {
        for (const definition of defaultConfig.block) {
            this.registerBlockElement(definition);
        }
        for (const definition of defaultConfig.inline) {
            this.registerInlineElement(definition);
        }
    }
    /**
     * Add new data schema definition describing block element.
     */
    registerBlockElement(definition) {
        this._definitions.set(definition.model, { ...definition, isBlock: true });
    }
    /**
     * Add new data schema definition describing inline element.
     */
    registerInlineElement(definition) {
        this._definitions.set(definition.model, { ...definition, isInline: true });
    }
    /**
     * Updates schema definition describing block element with new properties.
     *
     * Creates new scheme if it doesn't exist.
     * Array properties are concatenated with original values.
     *
     * @param definition Definition update.
     */
    extendBlockElement(definition) {
        this._extendDefinition({ ...definition, isBlock: true });
    }
    /**
     * Updates schema definition describing inline element with new properties.
     *
     * Creates new scheme if it doesn't exist.
     * Array properties are concatenated with original values.
     *
     * @param definition Definition update.
     */
    extendInlineElement(definition) {
        this._extendDefinition({ ...definition, isInline: true });
    }
    /**
     * Returns all definitions matching the given view name.
     *
     * @param includeReferences Indicates if this method should also include definitions of referenced models.
     */
    getDefinitionsForView(viewName, includeReferences = false) {
        const definitions = new Set();
        for (const definition of this._getMatchingViewDefinitions(viewName)) {
            if (includeReferences) {
                for (const reference of this._getReferences(definition.model)) {
                    definitions.add(reference);
                }
            }
            definitions.add(definition);
        }
        return definitions;
    }
    /**
     * Returns definitions matching the given view name.
     */
    _getMatchingViewDefinitions(viewName) {
        return Array.from(this._definitions.values())
            .filter(def => def.view && testViewName(viewName, def.view));
    }
    /**
     * Resolves all definition references registered for the given data schema definition.
     *
     * @param modelName Data schema model name.
     */
    *_getReferences(modelName) {
        const { modelSchema } = this._definitions.get(modelName);
        if (!modelSchema) {
            return;
        }
        const inheritProperties = ['inheritAllFrom', 'inheritTypesFrom', 'allowWhere', 'allowContentOf', 'allowAttributesOf'];
        for (const property of inheritProperties) {
            for (const referenceName of toArray(modelSchema[property] || [])) {
                const definition = this._definitions.get(referenceName);
                if (referenceName !== modelName && definition) {
                    yield* this._getReferences(definition.model);
                    yield definition;
                }
            }
        }
    }
    /**
     * Updates schema definition with new properties.
     *
     * Creates new scheme if it doesn't exist.
     * Array properties are concatenated with original values.
     *
     * @param definition Definition update.
     */
    _extendDefinition(definition) {
        const currentDefinition = this._definitions.get(definition.model);
        const mergedDefinition = mergeWith({}, currentDefinition, definition, (target, source) => {
            return Array.isArray(target) ? target.concat(source) : undefined;
        });
        this._definitions.set(definition.model, mergedDefinition);
    }
}
/**
 * Test view name against the given pattern.
 */
function testViewName(pattern, viewName) {
    if (typeof pattern === 'string') {
        return pattern === viewName;
    }
    if (pattern instanceof RegExp) {
        return pattern.test(viewName);
    }
    return false;
}
